# 数据库管理系统设计与实现考试大纲

## 题型

- 单选：1 分/题 \* 20 题
- 多选：2 分/题 \* 20 题
- 判断：1 分/题 \* 10 题
- 简答：30 分

## 重点内容

### 第一章

- DBMS 提供的能力
  - 持久存储：独立于程序，效率和灵活性更高
  - 编程接口：SQL 语句
  - 查询优化：索引如何用
  - 事务管理：ACID 准则。每一个查询（SELECT）或修改（UPDATE）动作就是一个事务（Transaction）。事务处理器主要分成两个部分。
    - 并发控制管理器（或调度器）：保证原子性（Atomicity）、隔离性（Isolation）
    - 日志和恢复管理器：保证一致性（Consistency）、持久性（Durability）

- DBMS 接受的两类命令来源
  - DBA 建立数据库模式的命令（DDL, Data Definition Language）
  - 普通用户和应用程序对数据的查询命令和修改命令（DML, Data Manipulation Language）

### 第二章

- 存储器层次：高速缓冲存储器、主存储器、辅助存储器

- **I/O 计算模型（必考）**：
  
  1. DBMS 中，数据不能装在主存中，必须考虑二级甚至三级存储器。
  2. 二级、三级存储器中处理数据的最佳算法，不同于在内存中处理的算法。
  3. **重点考虑降低磁盘访问次数。**
  
  例子：假设数据库有关系 `R`，有一个对元组的查询请求，该元组有一个确定的键值 `K`。为了快速响应查询，要在 `R` 上创建一个索引，用来标志带有键值 `K` 的元组出现的*磁盘块*，而*索引是否告诉我们元组在磁盘块的什么位置并不重要*。
  
  分析：读一个 4~64KB 的块大约要花 $10ms$，一个处理器在这 $10ms$ 内可以处理*上百万*条指令。然而，一旦块在主存中，即使采用线性搜索，搜索键值 `K` 仅执行*成千条*指令，因此在主存中搜索的时间将小于块访问时间的 $1\%$，因此可以忽略不计。
  
- 基本 SQL 数据类型及长度
  - 定长字符串 `char(n)`：n 个字符长度，如果为单字节字符集，则为 n 个字节
  - 变长字符串 `varchar(n)`：使用长度为 n+1 或 n+2 的字符数组表示，相应地占用空间为 n+1 或 n+2 字节

    - 方法 1 —— 长度 + 内容：第一个或第二个字符存储长度，后面存储内容。例如 `varchar(255)` 使用 1 个字节存储长度，`varchar(65535)` 使用 2 个字节存储长度。实际占用空间为 `n+1` 或 `n+2` 字节。
    - 方法 2 —— 空值作终止字符的字符串：在内容后加一个特殊的终止字符

    例如：属性 A 声明为 `varchar(10)`，实际占用 11 个字节。例如存储 `cat`，如使用方法 1，则表示为 `3cat`，这里的 3 是 8 位二进制整数，即 `00000011`，而不是字符 `3`；如使用方法 2，则存储 `cat^`（`^` 表示特殊的终止符号）。无论哪种方法，余下的 7 个位置无关紧要。
  - 整数类型 `int` / `integer`：4 字节
  - 浮点类型 `float` / `real`：单精度（`float`）4 字节，双精度（`double`）8 字节
  - 定长位串类型 `bit(n)`：$\lceil n/8 \rceil$ 字节
  - 变长位串类型 `bitvarying(n)`：使用长度为 n+1 或 n+2 的位串数组表示，相应地占用空间为 $\lceil n/8 \rceil + 1$ 或 $\lceil n/8 \rceil + 2$ 字节
  - 日期时间类型 `date` / `time` / `datetime` / `timestamp`
    - `date`：3 字节
    - `time`：3-6 字节
    - `datetime` / `timestamp`：4-8 字节

- 内存对齐

  记录的所有字段是*定长*的，将字段连接成*记录*

  将一个块从磁盘读入主存时，块的第一个字节肯定放到主存的*2 的高次幂*的某个位置。例如：如果块的大小是 4096，那么将放在 $2^{12}$ 的倍数处的位置。

  因此某些字段要放在 2 的高次幂的主存位置这一需求，转化为字段在磁盘块内的偏移必须具有相同的因子。

  **简化规则（必考）**：

  1. *每一条记录*从块内 4 的倍数的字节处开始
  2. 记录中*所有字段*对于记录起始位置的偏移量都是 4 的倍数

  例如，有如下表，其理论上占用的空间大小是 304 个字节。各个字段的偏移量修正为：

  - `name`: 0
  - `address`: 32
  - `gender`: 288
  - `birthday`: 292

  ```sql
  CREATE TABLE moviestar(
    name char(30),
    address varchar(255),
    gender char(1),
    birthday date
  );
  ```

- 两类地址
  - 物理地址：指明块或记录的物理位置
    - 主机 + 设备 ID + 柱面号 + 扇区号 + 块号（块地址）
    - 主机 + 设备 ID + 柱面号 + 扇区号 + 块号（块地址）+ 块内偏移量（记录地址）
  - 逻辑地址：每个记录有一个“逻辑地址”，是一个固定长度的字节串，通常是 “表名 + 记录 ID”

- **结构地址实现技术（必考）**：常用的物理地址和逻辑地址组合技巧是每一个块存储一个*偏移量表*，它保存了记录的块内偏移量。注意：在块内，偏移量表*从前往后*存储，记录*从后往前*存储。记录的结构地址是*块地址*加上*对应偏移量表项的偏移量*（参见图 3-8）

  ![图 3-8 (?)](结构地址实现技术.png)

- ~~指针混写~~（不考）

- 变长数据和记录：在下列四种情况下，必须是变长数据项（也叫字段）和记录：

  - 变长字段：比如电影明星的介绍，文字可长可短
  - 重复字段：比如电影明星每个出演的电影作为一个字段，则一个记录会有多个重复的字段
  - 可变格式记录：事先不知道记录的字段是什么，或者每个字段出现多次（比如*对象数据库*）
  - 不能装入一个块中的记录：有些记录跨越多个块

  例子：

  1. 假设一个病人记录包含以下定长字段：病人的出生日期、社会保险号码、病人 ID，每个字段都是 9 字节长。它还有下列变长字段：姓名、住址和病史。如果记录内一个指针需要 8 字节，记录长度是一个 2 字节整数，不包括变长字段空间，这条记录需要多少字节？这里假设不需要对字段进行对齐。($9*3+8*3+2=53$ 字节)
  2. 假设变长字段姓名、住址和病史的长度都符合均匀分布。对姓名来说，其范围为 20~60 字节；对住址来说，其范围是 40~80 字节；对病史来说，范围是 0~2000 字节，一个病人记录的平均长度是多少？

  - 姓名平均长度：$(20+60)/2=40$ 字节
  - 住址平均长度：$(40+80)/2=60$ 字节
  - 病史平均长度：$(0+2000)/2=1000$ 字节

  总长度 = 固定部分 (53 字节) + 姓名平均长度 (40 字节) + 住址平均长度 (60 字节) + 病史平均长度 (1000 字节) = 1153 字节

- 记录的修改：根据记录存放顺序，区分两种情况：

  - 记录不要求按照特定的顺序存储（堆文件）
  - **记录要按特定顺序，例如按照主键顺序存储（重点）**

### 第三章

- 稠密 / 稀疏索引的区别及示例图
  - 稠密索引：数据文件中*每个记录*在索引文件中都对应一个索引项。稠密索引文件亦由一系列的存储块构成，每个块存放记录的键和指向记录本身的指针（比如：块号 + 偏移量）。如果该索引是主索引（*一个顺序文件只有一个主索引*），则索引块中的键的顺序与数据文件中键的排序一致，参见 P91 图 4-3。

    例子（**必考**）：一个关系有 1,000,000 个元组，存储块大小为 4096 个字节。假设一个存储块可以存放 10 个元组，数据文件大约是 400MB。如果关系的键占 30 字节，指针占 8 字节，加上块头所需空间，可以在一个大小为 4096 的块中存放 100 个键-指针对。
  
    1. 稠密索引文件（*只有一层*）大约 40MB（10,000 个块）。
    2. 进一步，假定索引文件放在磁盘上用二分查找，$\log_2 10000$ 大约是 13，访问 13~14 个存储块就可以找到指定的键值。如果把一些索引块放到内存，I/O 次数远低于 14；如果整个索引放在主存中，则只需要 1 个 I/O。
    3. 自己计算不用索引的 I/O 次数（顺序查找 100,000 个块，二分查找 17 个块）
  
  - 稀疏索引：数据文件中*若干条记录*在索引文件中有一个索引项。通常一个数据块对应一个索引项，在此情况下，稀疏索引为*每个数据存储块*设一个*键-指针对*，键值是该数据块中第一个记录的对应值。参见 P92 图 4-4。查询时，先用二分查找在索引上定位*小于或等于 K*的最大键值，然后到对应的数据文件存储块搜索是否含 K。
  
    承接前面的例子：
  
    1. 由于数据文件有 100,000 个存储块（也是*键-指针对*的数目
    2. 一个*索引项*可以存储*100*个键-指针对
    3. 因此使用稀疏索引只需要*1,000*个索引块，大约*4M*大小，*这个大小可以完全放入主存！*
  
  两者的区别：
  
  1. 稀疏索引的大小*远小于*稠密索引，并且稀疏索引的指针要比稠密索引*短*（*稀疏索引的优点*）
  2. 稠密索引*不用检索数据文件*就可以回答诸如“是否存在键值为 K 的记录”这样的问题，但是稀疏索引要检索可能包含键值的所有数据块（*稠密索引的优点*）
  
- 多级索引（P94 图 4-5）
  
  1. 一级索引可以是稠密的也可以是稀疏的
  2. 二级以上的索引必须是稀疏的，否则浪费空间而无收益
  
  (1) 对溢出块和顺序块的影响原则：稠密索引针对记录，稀疏索引针对基本块（不包含溢出块）
  
  (2) 增加和删除记录只有影响块内的第一个记录时，稀疏索引才受影响
  
  (3) 移动记录时，只有变更了块内的第一个记录，稀疏索引才受影响
  
- 辅助索引（参见 P103 图 4-15）

  1. 一个关系上只有一个主索引，但可以有多个辅助索引
  2. 主索引决定了数据文件中记录的排列顺序（因此只能有一个）
  3. 辅助索引不影响数据文件中记录的存放位置，而只告诉某个记录的存放位置
  4. *直接建立在数据文件上的稀疏的辅助索引没有作用*，辅助索引必须是稠密的，并且通常有重复的键值项

- B 树

  1. *自动*保持与数据文件大小相适应的索引层次
  2. 对使用的存储空间进行管理，使每个*块*的充满程度在*半满*和*全满*之间，不需要溢出块。
  3. 是一棵*平衡树*，从树根到任一树叶的路径都*一样长*
  4. 通常 B 树有三层：根、中间层和叶，但也可以有任意多层
  5. 每个 B 树都有一个关键的参数 n，决定了 B 树中每个存储块的布局，每个存储块 最多有 n 个键值和 n + 1 个指针。

  关于存储块的限制：

  1. 根节点至少有两个指针（整个块只有一个键值和一个指针的平凡情况也可以）
  2. 叶节点中，最后一个指针指向右边的下一个叶节点存储块；每个叶块至少包含 $\lfloor{(n+1)/2\rfloor}$个指向数据记录的指针。如果第 i 个指针被使用，则指向第 i 个键值记录；未使用的指针为空且不指向任何地方。
  3. 在内部节点中，所有的 n+1 个指针都用来指向 B 树中下层的块，其中至少有 $\lceil(n+1)/2 \rceil$ 上括号个指针被使用。但如果是根节点，则不管 n 多大至少有*两个指针*被使用。如果有 j 个指针，则该块中有 j-1 个键值，记为 $K_1, ..., K_{j-1}$，第一个指针指向键值小于 $K_1$ 的记录部分，第二个指针指向键值大于等于 $K_1$ 且小于 $K_2$ 的部分，依此类推。最后，第 j 个指针指向键值大于等于 $K_{j-1}$ 部分。
  4. 任何一个节点的键值都是按照从左到右的升序排列。

  在 B 树的叶子节点上查找在 $[a,b]$ 之间的所有键值：

  1. 首先通过一次查找，寻找键 $a$。不论它是否存在，都可以到达可能出现 $a$ 的叶子节点，然后在该节点查找键 $a$ 或者大于 $a$ 的那些键
  2. 如果没有发现大于 $b$ 的键，就使用当前叶子节点指向下一个叶子节点的指针，并继续检查查找键和相应的指针，直到
     1. 找到一个大于 $b$ 的键，这时停止查找；或者
     2. 到了叶子节点的末尾，在这种情况下，转向下一个叶子节点并且重复这个过程

  插入过程：...

  删除过程：...

- **散列表（必考）**

  1. 参数 B 是桶的数目
  2. 散列函数可以将任意一个键映射成 0~B-1 的整数，这个整数即是对应的桶号，记作 h(K)
  3. 如果记录的查找键为 K，那么这个记录将存储到桶号为 h(K) 的桶中，这里 h 即是散列（哈希）函数

  辅助存储器上的散列表，区别于主存散列表（参见例 4.28，P125）：

  1. 桶数组由*存储块*组成，而不是内存链表
  2. 通过散列函数 h 散列到某个桶中的记录实际存储在存储块上
  3. 如果存储块满了，可以通过溢出块链来解决

  注意：要设计机制保证给一个整数 i，对应的第一个存储块的位置就可以找到

  如何处理增长？（**必考**）：

  - 溢出和重组
  - 动态散列
    - 可扩展散列：B 太小时，即将其翻倍
      - 哈希函数产生的 b 位输出，只用前 i 个位
      - 增加一个指向块的指针数组（桶数组），每次翻倍
      - 优点：如果桶数组小到可以存放到内存，可以在一个存储块中找到键值为 K 的记录，效率高
      - 缺点：桶数组翻倍时，可能无法全部放入主存，会使 I/O 大幅增加；某些块的分裂比逻辑上提前许多，从而大幅度浪费空间
    - 线性散列：每次 B 加一

### 第四章

- 如何进行查询处理
  - 原始方案：笛卡尔积、选择元组、进行投影

- 词法、语法分析：语法分析器接受 SQL 语句，并将其转化为语法分析数（学习 `yacc` 的用法）
- 生成初始逻辑查询计划（查询优化的过程，代数优化）
- 常见参数获取方法：通过对整个关系进行扫描，DBMS 可以计算属性各个值得直方图，常用直方图（用直方图估计结果更精准）
  1. 等宽直方图：选定宽度 w（取值范围）及常量 $v_0$，提供值为 $v$ 的元组数计数，$v$ 的范围是 $v_0 \le v \le v_0+w$，$v_0 + w \le v \le v_0 + 2w$
  2. 最频值直方图：列出最为公共的值以及它们出现的次数（经常和等宽直方图一起提供）。

### 第五章

- 三类恢复技术

  1. 单纯以后备副本为基础的恢复技术（一个副本）：周期性地把磁盘上的数据转储（dump）到其他磁盘或者磁带上。优点：实现简单，不增加数据库正常运行的开销；缺点：*不能将数据库恢复到最近的一致状态*。在文件系统中用的多，数据库系统中只用于小型和不重要的数据库系统。

  2. 后备复本 + 运行记录（日志，log 或 journal）（**必考**）

     记录运行是供恢复数据库运行历史的记录，通常包括四个内容：

     1. 活动事务表（Active Transaction List, ATL） —— 执行但尚未提交的事务列表（记录了所有正在执行、尚未提交的事务标识符（Transaction Identifier, TID））
     2. 提交事务表（Committed Transaction List, CTL） —— 已经提交的事务列表（记录了所有已经提交的事务标识符）
     3. **前像文件** —— 事务更新前涉及的磁盘块
     4. **后像文件** —— 事务更新后涉及的磁盘块

  3. 多复本恢复技术：系统中有多个数据库复本，而且这些复本具有独立 的失效模式（independent failure mode），这些复本互为备份，用于恢复。

- 前后像技术

  - 前像（Before Image）：一个数据库被一个事务更新时，所涉及的物理块更新前的映像（Image），以物理块为单位。有了前像，如果需要，可进行撤销操作（Undo）。
  - 后像（After Image）：数据库被一个事务更新时，所涉及的物理块更新后的映像，也是以物理块为单位。有了后像，如果需要，可进行重做操作（Redo）。

- 事务恢复的提交规则、先记后写规则

  提交（commit）规则：后像必须在事务提交前写入非易失存储器，即（完全）写入数据库或运行记录中。解释：

  1. 根据 ACID，提交的事务对数据库的影响是持久的。
  2. 提交规则并不要求后像一定在事务提交前写入数据库，如果后像已经写入了运行记录，即使未写入数据库或未完全写入数据库，事务也可以提交。
  3. 待事务提交后，再继续写入数据库。在此期间，如果发生故障，可用后像重做。

  先记后写规则：如果后像在事务提交前写入数据库，则必须首先把前像写入运行记录。解释：

  1. 事务提交前，都有可能失败，*须撤销事务对数据库做的一切更新*。
  2. 为此，必须在改动数据库前，先把前像写入运行记录。即，先把老的内容“留底”，才能写入新的内容。

- 事务更新的三种方案（**必考**）

  根据后像写入数据库（不是日志）时间的不同：

  1. 后像在事务提交*前完全*写入数据库...
  2. 后像在事务提交*后*才写入数据库...
  3. 后像在事务提交*前后*写入数据库...

- 恢复过程...
